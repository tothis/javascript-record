<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>util</title>
</head>
<body>

<h1 id="test" style="display: none" onclick="Util(this,{}).show()">文字</h1>

<script src="js/util.js"></script>
<script>

    // new Util(document.getElementById('test'),{}).show();

    function test(var1) {
        return function (var2) {
            console.log(var2)
            return function (var3) {
                console.log(var3)
                let array = [var1, var2, var3];
                return array.join('&');
            }
        }
    }

    // 包几层就可传几次参数
    console.log(test('one')('two')('three'));

    // typeof使用 typeof返回值为字符串类型
    console.log(typeof x); // undefined
    console.log(typeof (true)); // boolean
    console.log(typeof true); // boolean
    console.log(typeof '李磊'); // string
    console.log(typeof 123); // number
    console.log(typeof NaN); // number
    console.log(typeof null); // object    
    console.log(typeof (new String())); // object
    console.log(typeof (function () {
    })); // function
    console.log(typeof (class User {
    })); // function
    console.log(typeof x === undefined); // false
    console.log(typeof x === 'undefined'); // true

    // 使用typeof获取引用类型变量时 无论引用什么类型对象 都返回'object'
    // 此时需要instanceof来检测某个对象是不是另一个对象的实例
    // instanceof运算符用来测试一个对象在其原型链中是否存在一个构造函数的prototype属性
    let array = new Array();

    console.log(array instanceof Array); // true

    // Array是Object子类
    console.log(array instanceof Object) // true

    console.log('----');

    function A() {
    }

    let a = new A();
    console.log(Object.getPrototypeOf(a) === A.prototype);
    // Object.getPrototypeOf(a) === A.prototype
    console.log(a instanceof A); // true
    // Object.prototype.isPrototypeOf(a) === true
    console.log(a instanceof Object); // true

    // instanceof 可在继承关系中判断一个实例是否属于它的父类型
    function B() {
    }

    // B基础A js原型继承
    B.prototype = new A();
    let b = new B();
    console.log(b instanceof B) // true
    console.log(b instanceof A) // true

    console.log('----');
    console.log(Object instanceof Object); // true
    console.log(Function instanceof Function); // true
    console.log(Number instanceof Number); // false
    console.log(String instanceof String); // false
    console.log(Function instanceof Object); // true
    console.log(B instanceof Function); // true
    console.log(B instanceof B); // false
    console.log('----');

    /**
     * arguments
     * arguments.length为函数实参个数
     * arguments.callee引用函数自身
     * arguments对象不能显式创建
     * arguments对象函数开始执行时可用
     * arguments获取长度和下标取值与数组方法相同
     */
    function argumentsTest() {
        let temp = '';
        for (let i = 0; i < arguments.length; i++) {
            temp += arguments[i];
            if (i === arguments.length - 1) break;
            temp += ',';
        }

        console.log(arguments);
        console.log(arguments[0]);
        //console.log(arguments[0]());
        return temp;
    }

    console.log(argumentsTest(0, '1', "2")); // 0,1,2
    // callee属性 返回正被执行的Function对象 即当前函数主体
    let sum = function (num) {
        if (num === 1) {
            return 1;
        } else {
            // 使用arguments实现匿名的递归函数
            return arguments.callee(num - 1); // 2 1
        }
    }
    console.log(sum(3)); // 1

    // window length = 10;
    // 都可作为window的变量
    var length = 10;

    function c() {
        // console.log(this);
        console.log(this.length);
    }

    let d = {
        fun: function () {
            // 调用c方法 此时c中的this代表window对象
            c();
            // 调用arguments中第一个参数即如下c方法 此时c中的this为arguments对象
            arguments[0]();
        }
    };

    d.fun(c, 1); // 10 2

    // 传多个参数用argument求最大值
    function max() {
        let max = arguments[0];
        for (val of arguments) {
            if (val >= max) {
                max = val;
            }
        }
        return max;
    }

    console.log(max(1, "2", '3'));

    // 直接执行的匿名函数
    (function(){})();
    // 是一个表达式，会强制其理解成函数直接量方式，也就是表达式方式创建函数，
    // 它会返回函数对象的引用，最后使用小括号()调用此函数。
    (function(){}());
// 如果不用外面包裹的小括号，{}就会理解为复合语句，
// 那么function(){}就被理解为函数声明，但是没有标识符，所以会报错，
// 使用小括号以后，就会变成表达式，也会被理解为直接量方式。
    !function(){}();

    // 匿名函数
    (function (name) {
        console.log(name);
    })('李磊');
    // 如上等同于如下
    let fun = function (name) {
        console.log(name);
    };
    // 执行函数
    fun('李磊');

    var module1 = new Object({
        count: 0,
        fun1: function () {
            //...
        },
        fun2: function () {
            //...
        }
    });
    // 会暴露所有模块成员 内部状态可以被外部改写
    module1.count = 1;

    // 使用匿名函数可用return选择暴露的成员
    var module2 = (function () {
        let count = 0;
        let fun1 = function () {
            //...
        };
        let fun2 = function () {
            //...
        };
        return {
            fun1: fun1,
            fun2: fun2
        };
    })();
    console.info(module2.count); // undefined

    // 一个模块可分成多个部分 或者一个模块继承另一个模块 可采用放大模式augmentation

    var module2 = (function (module) {
        module.fun3 = function () {
            //...
        };
        return module;
    })(module2);
    // 上面代码作用为为module1模块添加了一个新方法fun3() 并返回新的module1对象

    // 模块各个部分从网络请求获取时 无法得知哪个部分先加载
    // 第一个执行部分可能加载一个不存在空对象 此时要采用宽放大模式 Loose augmentation
    var module2 = (function (module) {
        module.fun3 = function () {
            //...
        };
        return module;
    })(window.module1 || {});
</script>
</body>
</html>
